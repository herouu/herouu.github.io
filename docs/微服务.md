### 流量重放

[推荐一款技术人必备：线上引流神器GoReplay](https://mp.weixin.qq.com/s/cDpziHxtUnOCEDwNpeR1ow)

### 灰度发布

[有赞灰度发布与蓝绿发布实践](https://mp.weixin.qq.com/s/8SFtHdivnHAbQ4qq6diN5Q)

### 获取当前机器cpu核数

```java
Runtime.getRuntime().availableProcessors();
```

### 估算线程池大小

```vim
Nthreads = Ncpu x Ucpu x (1 + W/C)，其中
Ncpu = CPU核心数
Ucpu = CPU使用率，0~1
W/C = 等待时间与计算时间的比率
```

### 时间轮

[技巧篇：延迟任务处理神器之时间轮 HashedWheelTimer](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/21%20%20%E6%8A%80%E5%B7%A7%E7%AF%87%EF%BC%9A%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E8%BD%AE%20HashedWheelTimer.md)

* hutool使用

```java
 public static void main(String[] args) {
        SystemTimer timer = new SystemTimer();
        timer.setDelayQueueTimeout(1000);
        timer.start();
        timer.addTask(new TimerTask(() -> {
            System.out.println(1);
            System.out.println("任务已经完成");
        }, 1000));

        timer.stop();
        System.out.println("线程池已经关闭");
    }
```

### 布隆过滤器（英语：Bloom Filter）

[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！](https://juejin.cn/post/6844904007790673933)

```java
// 初始化
BitMapBloomFilter filter = new BitMapBloomFilter(10);
filter.add("123");
filter.add("abc");
filter.add("ddd");

// 查找
filter.contains("abc")
```

### 数据库迭代工具

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.collection.IterUtil;
import cn.hutool.core.collection.ListUtil;
import cn.hutool.core.convert.Convert;
import cn.hutool.core.lang.func.VoidFunc1;
import cn.hutool.core.util.NumberUtil;
import com.github.pagehelper.PageHelper;
import com.google.common.collect.AbstractIterator;

import java.util.List;
import java.util.Objects;


public class IterDBUtil {


    private static final Integer ONE_THOUSAND = 1000;

    /**
     * DEFAULT_FIELD
     */
    private static final String DEFAULT_FIELD = "id";

    /**
     * exec
     *
     * @param mode      mode
     * @param DBFunc  loadFunc
     * @param voidFunc1 voidFunc1
     * @param fieldName fieldName
     * @param <T>       T
     */
    public static <T> void exec(Mode mode, DBFunc<T> DBFunc, VoidFunc1<List<T>> voidFunc1, String fieldName) {
        exec(mode, ONE_THOUSAND, DBFunc, voidFunc1, fieldName);
    }


    /**
     * exec
     *
     * @param mode      mode
     * @param limit     limit
     * @param DBFunc  loadFunc
     * @param voidFunc1 voidFunc1
     * @param <T>       T
     */
    public static <T> void exec(Mode mode, Integer limit, DBFunc<T> DBFunc, VoidFunc1<List<T>> voidFunc1) {
        exec(mode, limit, DBFunc, voidFunc1, DEFAULT_FIELD);
    }

    /**
     * exec
     *
     * @param mode      mode
     * @param DBFunc  loadFunc
     * @param voidFunc1 voidFunc1
     * @param <T>       T
     */
    public static <T> void exec(Mode mode, DBFunc<T> DBFunc, VoidFunc1<List<T>> voidFunc1) {
        exec(mode, DBFunc, voidFunc1, DEFAULT_FIELD);
    }

    /**
     * exec
     *
     * @param DBFunc  loadFunc
     * @param voidFunc1 voidFunc1
     * @param <T>       T
     */
    public static <T> void exec(DBFunc<T> DBFunc, VoidFunc1<List<T>> voidFunc1) {
        exec(Mode.page, DBFunc, voidFunc1, DEFAULT_FIELD);
    }


    /**
     * exec
     *
     * @param mode      mode
     * @param limit     limit
     * @param DBFunc  loadFunc
     * @param voidFunc1 voidFunc1
     * @param fieldName fieldName
     * @param <T>       T
     */
    public static <T> void exec(Mode mode, int limit, DBFunc<T> DBFunc, VoidFunc1<List<T>> voidFunc1, String fieldName) {
        DbIter<T> tDbIter = new DbIter<>(mode, limit, DBFunc, fieldName);
        List<T> t = ListUtil.list(false);
        IterUtil.forEach(tDbIter, item -> CollUtil.addAll(t, item));
        List<List<T>> partition = ListUtil.partition(t, limit);
        IterUtil.forEach(IterUtil.getIter(partition),
                item -> {
                    if (CollUtil.isNotEmpty(item)) {
                        voidFunc1.callWithRuntimeException(item);
                    }
                });
    }


    /**
     * 数据库迭代器
     *
     *
     */
    private static class DbIter<T> extends AbstractIterator<List<T>> {


        /**
         * loadFunc
         */
        private final DBFunc<T> DBFunc;


        /**
         * mode
         */
        private final Mode mode;


        /**
         * offset
         */
        private int offset = 0;


        /**
         * maxId
         */
        private Long maxId;


        /**
         * fieldName
         */
        private String fieldName;

        /**
         * limit
         */
        private final int limit;


        /**
         * stop
         */
        private boolean stop = false;


        /**
         * DbIterator
         *
         * @param mode      mode
         * @param limit     limit
         * @param DBFunc  loadFunc
         * @param fieldName fieldName
         */
        public DbIter(Mode mode, int limit, DBFunc<T> DBFunc, String fieldName) {
            this.DBFunc = DBFunc;
            this.mode = mode;
            this.limit = limit;
            this.fieldName = fieldName;
        }

        @Override
        protected List<T> computeNext() {
            if (stop) {
                return endOfData();
            }
            List<T> load;

            if (mode == Mode.none) {
                load = loadFunc.load(maxId);
                this.stop = true;
                return load;
            }

            try {
                PageHelper.offsetPage(mode == Mode.page ? offset : 0, limit, false);
                load = loadFunc.load(maxId);
            } finally {
                PageHelper.clearPage();
            }
            if (CollUtil.size(load) < limit) {
                this.stop = true;
                return load;
            }
            if (mode == Mode.page) {
                offset = offset + limit;
            } else {
                maxId = maxId(load);
            }
            return load;
        }


        /**
         * maxId
         *
         * @param list list
         * @return Long
         */
        private Long maxId(List<T> list) {
            Long id = null;
            for (Object t : list) {
                Long aLong;
                if (t instanceof Long) {
                    aLong = Convert.toLong(t);
                } else if (BeanUtil.isBean(t.getClass())) {
                    aLong = Convert.toLong(BeanUtil.getProperty(t, fieldName));
                } else {
                    throw new IllegalArgumentException("不支持的数据类型");
                }
                if (Objects.isNull(id)) {
                    id = aLong;
                    continue;
                }
                if (NumberUtil.compare(id, aLong) < 0) {
                    id = aLong;
                }
            }
            return id;
        }
    }

    /**
     * 数据加载func
     *
     *
     */
    @FunctionalInterface
    public interface DBFunc<T> {
        /**
         * 加载数据
         *
         * @param id id
         * @return thelist
         */
        List<T> load(Long id);
    }


    /**
     * 迭代器模式 scroll-滚动分页 page-普通分页
     *
     *
     */
    public enum Mode {
        /**
         * scroll
         */
        scroll,
        /**
         * page
         */
        page,
        /**
         * none
         */
        none,
    }
}
```

### jvm

[硬核 JVM 压缩指针详解｜得物技术](https://mp.weixin.qq.com/s/4jDAjUZzPkCUQe6uagiLQw)
[亚毫秒GC暂停到底有多香？JDK17+ZGC初体验｜得物技术](https://mp.weixin.qq.com/s/ym6rjUAvcufLZrLPTMn-TQ)

### 消息总线

* spring cloud bus

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-bus-kafka</artifactId>
        </dependency>
```

```java
# 项目A 发送BusEvent,BusEvent为项目A、B共用

@Data
public class BusEvent extends RemoteApplicationEvent {

    private User user;

    public BusEvent(User user) {
        this.user = user;
    }

    public BusEvent() {
    }

    public BusEvent(Object source, User user, String originService, Destination destination) {
        super(source, originService, destination);
        this.user = user;
    }
}


@RestController
@RequestMapping("/user")
public class UserController {


    @Resource
    BusProperties busProperties;

    @Resource
    PathDestinationFactory pathDestinationFactory;

    @GetMapping("/push/bus")
    @IgnoreUserToken
    public void bus(@RequestParam String userId) {
        User user = new User();
        user.setUserId(userId);
        user.setUserName(userId);
        // destination为指定服务消费事件，可以为null,表示所有服务均可消费
        SpringUtil.publishEvent(new BusEvent(this, user, busProperties.getId(), pathDestinationFactory.getDestination("example-consumer:**")));
    }
}


# 项目B进行事件消费

@Component
@Slf4j
public class EventConsumer implements ApplicationListener<BusEvent> {

    @Override
    public void onApplicationEvent(BusEvent event) {
        log.info("event:{}", event);
    }
}

```

```yml
spring:
  cloud:
    bus:
      id: ${spring.application.name}
      destination: test-my-cloud-bus
    stream:
      bindings:
        springCloudBusInput:
          group: ${spring.cloud.bus.id}
        springCloudBusOutput:
          group: ${spring.cloud.bus.id}
```

```java

# bus事件消费源码 org.springframework.cloud.bus.BusConsumer

public class BusConsumer implements Consumer<RemoteApplicationEvent> {

 private final Log log = LogFactory.getLog(getClass());

 private final ApplicationEventPublisher publisher;

 private final ServiceMatcher serviceMatcher;

 private final ObjectProvider<BusBridge> busBridge;

 private final BusProperties properties;

 private final Destination.Factory destinationFactory;

 public BusConsumer(ApplicationEventPublisher publisher, ServiceMatcher serviceMatcher,
   ObjectProvider<BusBridge> busBridge, BusProperties properties, Destination.Factory destinationFactory) {
  this.publisher = publisher;
  this.serviceMatcher = serviceMatcher;
  this.busBridge = busBridge;
  this.properties = properties;
  this.destinationFactory = destinationFactory;
 }

 @Override
 public void accept(RemoteApplicationEvent event) {
  if (event instanceof AckRemoteApplicationEvent) {
   if (this.properties.getTrace().isEnabled() && !this.serviceMatcher.isFromSelf(event)
     && this.publisher != null) {
    this.publisher.publishEvent(event);
   }
   // If it's an ACK we are finished processing at this point
   return;
  }

  if (log.isDebugEnabled()) {
   log.debug("Received remote event from bus: " + event);
  }

  // 注意此处判断，满足该条件this.serviceMatcher.isForSelf(event)，发送spring本地事件后，才能被ApplicationListener捕获
  if (this.serviceMatcher.isForSelf(event) && this.publisher != null) {
   if (!this.serviceMatcher.isFromSelf(event)) {
    this.publisher.publishEvent(event);
   }
   if (this.properties.getAck().isEnabled()) {
    AckRemoteApplicationEvent ack = new AckRemoteApplicationEvent(this, this.serviceMatcher.getBusId(),
      destinationFactory.getDestination(this.properties.getAck().getDestinationService()),
      event.getDestinationService(), event.getId(), event.getClass());
    this.busBridge.ifAvailable(bridge -> bridge.send(ack));
    this.publisher.publishEvent(ack);
   }
  }
  if (this.properties.getTrace().isEnabled() && this.publisher != null) {
   // We are set to register sent events so publish it for local consumption,
   // irrespective of the origin
   this.publisher.publishEvent(new SentApplicationEvent(this, event.getOriginService(),
     event.getDestinationService(), event.getId(), event.getClass()));
  }
 }

}


```

### 熔断器

* sentinel

### 链路追踪

* skywalking

### 注册中心/配置中心

* nacos

### springboot 拓展点

[掌握这些 Spring Boot 启动扩展点，已经超过 90% 的人了！](https://cloud.tencent.com/developer/article/2104367)

### 分布式共识算法raft实现sofajraft

<https://github.com/sofastack/sofa-jraft>

<https://www.sofastack.tech/blog/sofa-channel-8-retrospect/>

### tomcat+TransmittableThreadLocal

```yml
#验证设置tomcat线程数
server:
  tomcat:
    max-threads: 1
    min-spare-threads: 1
```

```java
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import org.apache.coyote.AbstractProtocol;
import org.apache.tomcat.util.threads.ThreadPoolExecutor;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.alibaba.ttl.threadpool.TtlExecutors;

import cn.hutool.core.thread.ThreadUtil;

@Configuration
public class TomcatConfig {

    @Bean
    public TomcatServletWebServerFactory tomcatFactory(ServerProperties serverProperties) {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.addConnectorCustomizers(connector -> {
            // 设置自定义的线程池
            AbstractProtocol protocol = (AbstractProtocol)connector.getProtocolHandler();
            protocol.setExecutor(createThreadPool(serverProperties));
        });
        return factory;
    }

    private Executor createThreadPool(ServerProperties serverProperties) {
        ServerProperties.Tomcat tomcat = serverProperties.getTomcat();

        ThreadPoolExecutor executor = new ThreadPoolExecutor(tomcat.getMinSpareThreads(), tomcat.getMaxThreads(), 60L,
            TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
            // 禁用inheritable
            TtlExecutors.getDisableInheritableThreadFactory(ThreadUtil.createThreadFactory("my-thread-pool-")),
            new ThreadPoolExecutor.DiscardPolicy());

        return TtlExecutors.getTtlExecutor(executor);
    }
}
```
